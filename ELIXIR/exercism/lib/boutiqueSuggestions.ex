defmodule BoutiqueSuggestions do
  @moduledoc"""
  List Comprehensions
  Comprehensions provide a facility for transforming Enumerables easily and declaratively.

  To declare a very simple comprehension, we can use the for keyword followed by a generator and a do-block
  which creates the new values from the enumerated values.

  for n <- [0, 1, 2, 3], do: n + 1
  # => [1, 2, 3, 4]
  Comprehensions can also have filters. Values that do not pass the filter are removed from the final list:

  for n <- [0, 1, 2, 3], n > 1, do: n + 1
  # => [3, 4]
  We can declare more complicated comprehensions over several lines:

  for {atom, number} <- [a: 1, b: 2, c: 3, d: 4],
      rem(number, 2) == 0 do
    atom
  end

  # => [:b, :d]
  A cartesian product can be created using multiple generators.
  That means that each value generated by the first generator will be paired once with each value generated by the second generator:

  for x <- [0, 1],
      y <- [0, 1] do
    {x, y}
  end

  # => [{0, 0}, {0, 1}, {1, 0}, {1, 1}]
  """
  @spec get_combination([map()], [map()], keyword()) :: [{map(), map()}]
  def get_combinations(tops, bottoms, options \\ []) do
    max_price = Keyword.get(options, :maximum_price, 100.0)
    for top <- tops,
        bottom <- bottoms,
        top[:base_color] != bottom[:base_color],
        top[:price] + bottom[:price] <= max_price do
        {top, bottom}
      end
  end
end
